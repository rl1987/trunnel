
/* doc/socks5.c -- generated by trunnel. */
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <arpa/inet.h>
#include "trunnel-impl.h"
#include "socks5.h"

#define trunnel_malloc(x) (malloc((x)))
#define trunnel_free_(x) (free(x))
#define trunnel_free(x) (free(x))
#define trunnel_calloc(a,b) (calloc(a,b))
#define trunnel_assert(x) assert(x)
#define trunnel_abort() abort()

/* XXXX stick this in a file or something */
static void *trunnel_reallocarray(void *a, size_t x, size_t y)
{
   if (x > SIZE_MAX / y)
     return NULL;
   return realloc(a, x * y);
}

static void trunnel_set_uint32(void *p, uint32_t v) {
  memcpy(p, &v, 4);
}
static void trunnel_set_uint16(void *p, uint16_t v) {
  memcpy(p, &v, 2);
}
static void trunnel_set_uint8(void *p, uint8_t v) {
  memcpy(p, &v, 1);
}

static uint32_t trunnel_get_uint32(const void *p) {
  uint32_t x;
  memcpy(&x, p, 4);
  return x;
}
static uint16_t trunnel_get_uint16(const void *p) {
  uint16_t x;
  memcpy(&x, p, 2);
  return x;
}
static uint8_t trunnel_get_uint8(const void *p) {
  return *(const uint8_t*)p;
}
static uint64_t trunnel_get_uint64(const void *p) {
  uint64_t x;
  memcpy(&x, p, 8);
  return x;
}

static void trunnel_set_uint64(void *p, uint64_t v) {
  memcpy(p, &v, 8);
}

static uint64_t trunnel_htonll(uint64_t a)
{
#if BYTE_ORDER == BIG_ENDIAN
  return a;
#else
  return htonl(a>>32) | (((uint64_t)htonl(a))<<32);
#endif
}
static uint64_t trunnel_ntohll(uint64_t a)
{
  return trunnel_htonll(a);
}
static ssize_t domainname_parse_into(domainname_t *obj, const uint8_t *input, const size_t len_in);
static ssize_t socks4_client_request_parse_into(socks4_client_request_t *obj, const uint8_t *input, const size_t len_in);
static ssize_t socks4_server_reply_parse_into(socks4_server_reply_t *obj, const uint8_t *input, const size_t len_in);
static ssize_t socks5_client_version_parse_into(socks5_client_version_t *obj, const uint8_t *input, const size_t len_in);
static ssize_t socks5_server_method_parse_into(socks5_server_method_t *obj, const uint8_t *input, const size_t len_in);
static ssize_t socks5_client_request_parse_into(socks5_client_request_t *obj, const uint8_t *input, const size_t len_in);
static ssize_t socks5_server_reply_parse_into(socks5_server_reply_t *obj, const uint8_t *input, const size_t len_in);
domainname_t *
domainname_new(void)
{
  return trunnel_calloc(1, sizeof(domainname_t));
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
domainname_clear(domainname_t *obj)
{
  (void) obj;
  trunnel_free(obj->name);
}

void
domainname_free(domainname_t *obj)
{
  if (obj == NULL)
    return;
  domainname_clear(obj);
  trunnel_free_(obj);
}

/** Check whether the internal state of the domainname in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
static const char *
domainname_check(const domainname_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  return NULL;
}

ssize_t
domainname_encode(uint8_t *output, const size_t avail, const domainname_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;

  if (NULL != (msg = domainname_check(obj)))
    goto check_failed;


  /* Encode u8 len */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->len));
  written += 1; ptr += 1;

  /* Encode char name[len] */
  trunnel_assert(written <= avail);
  if (avail - written < obj->len) goto truncated;
  memcpy(ptr, obj->name, obj->len);
  written += obj->len; ptr += obj->len;

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As domainname_parse(), but do not allocate the output object.
 */
static ssize_t
domainname_parse_into(domainname_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;


  /* Parse u8 len */
  if (remaining < 1)
    goto truncated;
  obj->len = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse char name[len] */
#if SIZE_MAX <= UINT8_MAX
  if (((size_t)obj->len) > SIZE_MAX - 1)  goto overflow;
#endif
  if (remaining < obj->len)
    goto truncated;
  if (NULL == (obj->name = trunnel_malloc(((size_t)obj->len) + 1)))
    goto overflow;
  obj->name[obj->len] = 0;
  memcpy(obj->name, ptr, obj->len);
  remaining -= obj->len; ptr += obj->len;
  return len_in - remaining;

 overflow:
  return -1;
 truncated:
  return -2;
}

ssize_t
domainname_parse(domainname_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = domainname_new();
  result = domainname_parse_into(*output, input, len_in);
  if (result < 0) {
    domainname_free(*output);
    *output = NULL;
  }
  return result;
}
socks4_client_request_t *
socks4_client_request_new(void)
{
  return trunnel_calloc(1, sizeof(socks4_client_request_t));
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
socks4_client_request_clear(socks4_client_request_t *obj)
{
  (void) obj;
  trunnel_free(obj->username);
  trunnel_free(obj->socks4a_addr_hostname);
}

void
socks4_client_request_free(socks4_client_request_t *obj)
{
  if (obj == NULL)
    return;
  socks4_client_request_clear(obj);
  trunnel_free_(obj);
}

/** Check whether the internal state of the socks4_client_request in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
static const char *
socks4_client_request_check(const socks4_client_request_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (! (obj->version == 4))
    return "Integer out of bounds";
  if (! (obj->command == CMD_CONNECT || obj->command == CMD_BIND))
    return "Integer out of bounds";
  if (NULL == obj->username)
    return "Missing username";
  switch (obj->addr) {

    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
    case 229:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 255:
      if (NULL == obj->socks4a_addr_hostname)
        return "Missing socks4a_addr_hostname";
      break;

    default:
      break;
  }
  return NULL;
}

ssize_t
socks4_client_request_encode(uint8_t *output, const size_t avail, const socks4_client_request_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;

  if (NULL != (msg = socks4_client_request_check(obj)))
    goto check_failed;


  /* Encode u8 version IN [4] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->version));
  written += 1; ptr += 1;

  /* Encode u8 command IN [CMD_CONNECT, CMD_BIND] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->command));
  written += 1; ptr += 1;

  /* Encode u16 port */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, htons(obj->port));
  written += 2; ptr += 2;

  /* Encode u32 addr */
  trunnel_assert(written <= avail);
  if (avail - written < 4)
    goto truncated;
  trunnel_set_uint32(ptr, htonl(obj->addr));
  written += 4; ptr += 4;

  /* Encode nulterm username */
  trunnel_assert(written <= avail);
  {
    size_t len = strlen(obj->username);
    if (len >= avail - written)
      goto truncated;
    memcpy(ptr, obj->username, len + 1);
    ptr += len + 1; written += len + 1;
  }

  /* Encode union socks4a_addr[addr] */
  trunnel_assert(written <= avail);
  switch (obj->addr) {

    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
    case 229:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 255:

      /* Encode nulterm socks4a_addr_hostname */
      trunnel_assert(written <= avail);
      {
        size_t len = strlen(obj->socks4a_addr_hostname);
        if (len >= avail - written)
          goto truncated;
        memcpy(ptr, obj->socks4a_addr_hostname, len + 1);
        ptr += len + 1; written += len + 1;
      }
      break;

    default:
      break;
  }

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As socks4_client_request_parse(), but do not allocate the output
 * object.
 */
static ssize_t
socks4_client_request_parse_into(socks4_client_request_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;


  /* Parse u8 version IN [4] */
  if (remaining < 1)
    goto truncated;
  obj->version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->version == 4))
    goto fail;

  /* Parse u8 command IN [CMD_CONNECT, CMD_BIND] */
  if (remaining < 1)
    goto truncated;
  obj->command = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->command == CMD_CONNECT || obj->command == CMD_BIND))
    goto fail;

  /* Parse u16 port */
  if (remaining < 2)
    goto truncated;
  obj->port = ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse u32 addr */
  if (remaining < 4)
    goto truncated;
  obj->addr = ntohl(trunnel_get_uint32(ptr));
  remaining -= 4; ptr += 4;

  /* Parse nulterm username */
  {
    uint8_t *eos = (uint8_t*)memchr(ptr, 0, remaining);
    size_t memlen;
    if (eos == NULL)
      goto truncated;
    trunnel_assert(eos >= ptr);
    trunnel_assert((size_t)(eos - ptr) < SIZE_MAX - 1);
    memlen = ((size_t)(eos - ptr)) + 1;
    obj->username = trunnel_malloc(memlen);
    memcpy(obj->username, ptr, memlen);
    remaining -= memlen; ptr += memlen;
  }

  /* Parse union socks4a_addr[addr] */
  switch (obj->addr) {

    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
    case 229:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 255:

      /* Parse nulterm socks4a_addr_hostname */
      {
        uint8_t *eos = (uint8_t*)memchr(ptr, 0, remaining);
        size_t memlen;
        if (eos == NULL)
          goto truncated;
        trunnel_assert(eos >= ptr);
        trunnel_assert((size_t)(eos - ptr) < SIZE_MAX - 1);
        memlen = ((size_t)(eos - ptr)) + 1;
        obj->socks4a_addr_hostname = trunnel_malloc(memlen);
        memcpy(obj->socks4a_addr_hostname, ptr, memlen);
        remaining -= memlen; ptr += memlen;
      }
      break;

    default:
      break;
  }
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
socks4_client_request_parse(socks4_client_request_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = socks4_client_request_new();
  result = socks4_client_request_parse_into(*output, input, len_in);
  if (result < 0) {
    socks4_client_request_free(*output);
    *output = NULL;
  }
  return result;
}
socks4_server_reply_t *
socks4_server_reply_new(void)
{
  return trunnel_calloc(1, sizeof(socks4_server_reply_t));
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
socks4_server_reply_clear(socks4_server_reply_t *obj)
{
  (void) obj;
}

void
socks4_server_reply_free(socks4_server_reply_t *obj)
{
  if (obj == NULL)
    return;
  socks4_server_reply_clear(obj);
  trunnel_free_(obj);
}

/** Check whether the internal state of the socks4_server_reply in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
static const char *
socks4_server_reply_check(const socks4_server_reply_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (! (obj->version == 4))
    return "Integer out of bounds";
  return NULL;
}

ssize_t
socks4_server_reply_encode(uint8_t *output, const size_t avail, const socks4_server_reply_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;

  if (NULL != (msg = socks4_server_reply_check(obj)))
    goto check_failed;


  /* Encode u8 version IN [4] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->version));
  written += 1; ptr += 1;

  /* Encode u8 status */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->status));
  written += 1; ptr += 1;

  /* Encode u16 port */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, htons(obj->port));
  written += 2; ptr += 2;

  /* Encode u32 addr */
  trunnel_assert(written <= avail);
  if (avail - written < 4)
    goto truncated;
  trunnel_set_uint32(ptr, htonl(obj->addr));
  written += 4; ptr += 4;

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As socks4_server_reply_parse(), but do not allocate the output
 * object.
 */
static ssize_t
socks4_server_reply_parse_into(socks4_server_reply_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;


  /* Parse u8 version IN [4] */
  if (remaining < 1)
    goto truncated;
  obj->version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->version == 4))
    goto fail;

  /* Parse u8 status */
  if (remaining < 1)
    goto truncated;
  obj->status = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u16 port */
  if (remaining < 2)
    goto truncated;
  obj->port = ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse u32 addr */
  if (remaining < 4)
    goto truncated;
  obj->addr = ntohl(trunnel_get_uint32(ptr));
  remaining -= 4; ptr += 4;
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
socks4_server_reply_parse(socks4_server_reply_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = socks4_server_reply_new();
  result = socks4_server_reply_parse_into(*output, input, len_in);
  if (result < 0) {
    socks4_server_reply_free(*output);
    *output = NULL;
  }
  return result;
}
socks5_client_version_t *
socks5_client_version_new(void)
{
  return trunnel_calloc(1, sizeof(socks5_client_version_t));
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
socks5_client_version_clear(socks5_client_version_t *obj)
{
  (void) obj;
  TRUNNEL_DYNARRAY_CLEAR(&obj->methods);
}

void
socks5_client_version_free(socks5_client_version_t *obj)
{
  if (obj == NULL)
    return;
  socks5_client_version_clear(obj);
  trunnel_free_(obj);
}

size_t
socks5_client_version_get_methods_len(const socks5_client_version_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->methods);
}

uint8_t
socks5_client_version_get_methods(const socks5_client_version_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->methods, idx);
}

void
socks5_client_version_set_methods(socks5_client_version_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->methods, idx, elt);
}

int
socks5_client_version_add_methods(socks5_client_version_t *inp, uint8_t elt)
{
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->methods, elt);
  return 0;
 trunnel_alloc_failed:
  return -1;
}

/** Check whether the internal state of the socks5_client_version in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
static const char *
socks5_client_version_check(const socks5_client_version_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (! (obj->version == 5))
    return "Integer out of bounds";
  if (TRUNNEL_DYNARRAY_LEN(&obj->methods) != obj->n_methods)
    return "Length mismatch for methods";
  return NULL;
}

ssize_t
socks5_client_version_encode(uint8_t *output, const size_t avail, const socks5_client_version_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;

  if (NULL != (msg = socks5_client_version_check(obj)))
    goto check_failed;


  /* Encode u8 version IN [5] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->version));
  written += 1; ptr += 1;

  /* Encode u8 n_methods */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->n_methods));
  written += 1; ptr += 1;

  /* Encode u8 methods[n_methods] */
  trunnel_assert(written <= avail);
  if (avail - written < obj->n_methods) goto truncated;
  memcpy(ptr, obj->methods.elts_, obj->n_methods);
  written += obj->n_methods; ptr += obj->n_methods;

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As socks5_client_version_parse(), but do not allocate the output
 * object.
 */
static ssize_t
socks5_client_version_parse_into(socks5_client_version_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;


  /* Parse u8 version IN [5] */
  if (remaining < 1)
    goto truncated;
  obj->version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->version == 5))
    goto fail;

  /* Parse u8 n_methods */
  if (remaining < 1)
    goto truncated;
  obj->n_methods = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 methods[n_methods] */
  if (remaining < obj->n_methods)
    goto truncated;
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->methods, obj->n_methods);
  obj->methods.n_ = obj->n_methods;
  memcpy(obj->methods.elts_, ptr, obj->n_methods);
  remaining -= obj->n_methods; ptr += obj->n_methods;
  return len_in - remaining;

 truncated:
  return -2;
 trunnel_alloc_failed:
  return -1;
 fail:
  result = -1;
  return result;
}

ssize_t
socks5_client_version_parse(socks5_client_version_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = socks5_client_version_new();
  result = socks5_client_version_parse_into(*output, input, len_in);
  if (result < 0) {
    socks5_client_version_free(*output);
    *output = NULL;
  }
  return result;
}
socks5_server_method_t *
socks5_server_method_new(void)
{
  return trunnel_calloc(1, sizeof(socks5_server_method_t));
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
socks5_server_method_clear(socks5_server_method_t *obj)
{
  (void) obj;
}

void
socks5_server_method_free(socks5_server_method_t *obj)
{
  if (obj == NULL)
    return;
  socks5_server_method_clear(obj);
  trunnel_free_(obj);
}

/** Check whether the internal state of the socks5_server_method in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
static const char *
socks5_server_method_check(const socks5_server_method_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (! (obj->version == 5))
    return "Integer out of bounds";
  return NULL;
}

ssize_t
socks5_server_method_encode(uint8_t *output, const size_t avail, const socks5_server_method_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;

  if (NULL != (msg = socks5_server_method_check(obj)))
    goto check_failed;


  /* Encode u8 version IN [5] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->version));
  written += 1; ptr += 1;

  /* Encode u8 methods */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->methods));
  written += 1; ptr += 1;

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As socks5_server_method_parse(), but do not allocate the output
 * object.
 */
static ssize_t
socks5_server_method_parse_into(socks5_server_method_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;


  /* Parse u8 version IN [5] */
  if (remaining < 1)
    goto truncated;
  obj->version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->version == 5))
    goto fail;

  /* Parse u8 methods */
  if (remaining < 1)
    goto truncated;
  obj->methods = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
socks5_server_method_parse(socks5_server_method_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = socks5_server_method_new();
  result = socks5_server_method_parse_into(*output, input, len_in);
  if (result < 0) {
    socks5_server_method_free(*output);
    *output = NULL;
  }
  return result;
}
socks5_client_request_t *
socks5_client_request_new(void)
{
  return trunnel_calloc(1, sizeof(socks5_client_request_t));
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
socks5_client_request_clear(socks5_client_request_t *obj)
{
  (void) obj;
  domainname_clear(&obj->dest_addr_domainname);
}

void
socks5_client_request_free(socks5_client_request_t *obj)
{
  if (obj == NULL)
    return;
  socks5_client_request_clear(obj);
  trunnel_free_(obj);
}

/** Check whether the internal state of the socks5_client_request in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
static const char *
socks5_client_request_check(const socks5_client_request_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (! (obj->version == 5))
    return "Integer out of bounds";
  if (! (obj->command == CMD_CONNECT || obj->command == CMD_BIND || obj->command == CMD_UDP_ASSOCIATE))
    return "Integer out of bounds";
  if (! (obj->reserved == 0))
    return "Integer out of bounds";
  switch (obj->atype) {

    case ATYPE_IPV4:
      break;

    case ATYPE_IPV6:
      break;

    case ATYPE_DOMAINNAME:
      {
        const char *msg;
        if (NULL != (msg = domainname_check(&obj->dest_addr_domainname)))
          return msg;
      }
      break;

    default:
        return "Bad tag for union";
      break;
  }
  return NULL;
}

ssize_t
socks5_client_request_encode(uint8_t *output, const size_t avail, const socks5_client_request_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;

  if (NULL != (msg = socks5_client_request_check(obj)))
    goto check_failed;


  /* Encode u8 version IN [5] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->version));
  written += 1; ptr += 1;

  /* Encode u8 command IN [CMD_CONNECT, CMD_BIND, CMD_UDP_ASSOCIATE] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->command));
  written += 1; ptr += 1;

  /* Encode u8 reserved IN [0] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->reserved));
  written += 1; ptr += 1;

  /* Encode u8 atype */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->atype));
  written += 1; ptr += 1;

  /* Encode union dest_addr[atype] */
  trunnel_assert(written <= avail);
  switch (obj->atype) {

    case ATYPE_IPV4:

      /* Encode u32 dest_addr_ipv4 */
      trunnel_assert(written <= avail);
      if (avail - written < 4)
        goto truncated;
      trunnel_set_uint32(ptr, htonl(obj->dest_addr_ipv4));
      written += 4; ptr += 4;
      break;

    case ATYPE_IPV6:

      /* Encode u8 dest_addr_ipv6[16] */
      trunnel_assert(written <= avail);
      if (avail - written < 16)
        goto truncated;
      memcpy(ptr, obj->dest_addr_ipv6, 16);
      written += 16; ptr += 16;
      break;

    case ATYPE_DOMAINNAME:

      /* Encode struct domainname dest_addr_domainname */
      trunnel_assert(written <= avail);
      result = domainname_encode(ptr, avail - written, &obj->dest_addr_domainname);
      if (result < 0)
        goto fail;
      written += result; ptr += result;
      break;

    default:
      trunnel_assert(0);
      break;
  }

  /* Encode u16 dest_port */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, htons(obj->dest_port));
  written += 2; ptr += 2;

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As socks5_client_request_parse(), but do not allocate the output
 * object.
 */
static ssize_t
socks5_client_request_parse_into(socks5_client_request_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;


  /* Parse u8 version IN [5] */
  if (remaining < 1)
    goto truncated;
  obj->version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->version == 5))
    goto fail;

  /* Parse u8 command IN [CMD_CONNECT, CMD_BIND, CMD_UDP_ASSOCIATE] */
  if (remaining < 1)
    goto truncated;
  obj->command = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->command == CMD_CONNECT || obj->command == CMD_BIND || obj->command == CMD_UDP_ASSOCIATE))
    goto fail;

  /* Parse u8 reserved IN [0] */
  if (remaining < 1)
    goto truncated;
  obj->reserved = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->reserved == 0))
    goto fail;

  /* Parse u8 atype */
  if (remaining < 1)
    goto truncated;
  obj->atype = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse union dest_addr[atype] */
  switch (obj->atype) {

    case ATYPE_IPV4:

      /* Parse u32 dest_addr_ipv4 */
      if (remaining < 4)
        goto truncated;
      obj->dest_addr_ipv4 = ntohl(trunnel_get_uint32(ptr));
      remaining -= 4; ptr += 4;
      break;

    case ATYPE_IPV6:

      /* Parse u8 dest_addr_ipv6[16] */
      if (remaining < (16))
        goto truncated;
      memcpy(obj->dest_addr_ipv6, ptr, 16);
      {
        unsigned idx;
        for (idx = 0; idx < 16; ++idx)
          obj->dest_addr_ipv6[idx] = (obj->dest_addr_ipv6[idx]);
      }
      remaining -= 16; ptr += 16;
      break;

    case ATYPE_DOMAINNAME:

      /* Parse struct domainname dest_addr_domainname */
      result = domainname_parse_into(&obj->dest_addr_domainname, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    default:
      goto fail;
      break;
  }

  /* Parse u16 dest_port */
  if (remaining < 2)
    goto truncated;
  obj->dest_port = ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  if (result >= 0) result = -1;
  return result;
 fail:
  result = -1;
  return result;
}

ssize_t
socks5_client_request_parse(socks5_client_request_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = socks5_client_request_new();
  result = socks5_client_request_parse_into(*output, input, len_in);
  if (result < 0) {
    socks5_client_request_free(*output);
    *output = NULL;
  }
  return result;
}
socks5_server_reply_t *
socks5_server_reply_new(void)
{
  return trunnel_calloc(1, sizeof(socks5_server_reply_t));
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
socks5_server_reply_clear(socks5_server_reply_t *obj)
{
  (void) obj;
  domainname_clear(&obj->bind_addr_domainname);
}

void
socks5_server_reply_free(socks5_server_reply_t *obj)
{
  if (obj == NULL)
    return;
  socks5_server_reply_clear(obj);
  trunnel_free_(obj);
}

/** Check whether the internal state of the socks5_server_reply in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
static const char *
socks5_server_reply_check(const socks5_server_reply_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (! (obj->version == 5))
    return "Integer out of bounds";
  if (! (obj->reserved == 0))
    return "Integer out of bounds";
  switch (obj->atype) {

    case ATYPE_IPV4:
      break;

    case ATYPE_IPV6:
      break;

    case ATYPE_DOMAINNAME:
      {
        const char *msg;
        if (NULL != (msg = domainname_check(&obj->bind_addr_domainname)))
          return msg;
      }
      break;

    default:
        return "Bad tag for union";
      break;
  }
  return NULL;
}

ssize_t
socks5_server_reply_encode(uint8_t *output, const size_t avail, const socks5_server_reply_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;

  if (NULL != (msg = socks5_server_reply_check(obj)))
    goto check_failed;


  /* Encode u8 version IN [5] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->version));
  written += 1; ptr += 1;

  /* Encode u8 reply */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->reply));
  written += 1; ptr += 1;

  /* Encode u8 reserved IN [0] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->reserved));
  written += 1; ptr += 1;

  /* Encode u8 atype */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->atype));
  written += 1; ptr += 1;

  /* Encode union bind_addr[atype] */
  trunnel_assert(written <= avail);
  switch (obj->atype) {

    case ATYPE_IPV4:

      /* Encode u32 bind_addr_ipv4 */
      trunnel_assert(written <= avail);
      if (avail - written < 4)
        goto truncated;
      trunnel_set_uint32(ptr, htonl(obj->bind_addr_ipv4));
      written += 4; ptr += 4;
      break;

    case ATYPE_IPV6:

      /* Encode u8 bind_addr_ipv6[16] */
      trunnel_assert(written <= avail);
      if (avail - written < 16)
        goto truncated;
      memcpy(ptr, obj->bind_addr_ipv6, 16);
      written += 16; ptr += 16;
      break;

    case ATYPE_DOMAINNAME:

      /* Encode struct domainname bind_addr_domainname */
      trunnel_assert(written <= avail);
      result = domainname_encode(ptr, avail - written, &obj->bind_addr_domainname);
      if (result < 0)
        goto fail;
      written += result; ptr += result;
      break;

    default:
      trunnel_assert(0);
      break;
  }

  /* Encode u16 bind_port */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, htons(obj->bind_port));
  written += 2; ptr += 2;

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As socks5_server_reply_parse(), but do not allocate the output
 * object.
 */
static ssize_t
socks5_server_reply_parse_into(socks5_server_reply_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;


  /* Parse u8 version IN [5] */
  if (remaining < 1)
    goto truncated;
  obj->version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->version == 5))
    goto fail;

  /* Parse u8 reply */
  if (remaining < 1)
    goto truncated;
  obj->reply = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 reserved IN [0] */
  if (remaining < 1)
    goto truncated;
  obj->reserved = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->reserved == 0))
    goto fail;

  /* Parse u8 atype */
  if (remaining < 1)
    goto truncated;
  obj->atype = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse union bind_addr[atype] */
  switch (obj->atype) {

    case ATYPE_IPV4:

      /* Parse u32 bind_addr_ipv4 */
      if (remaining < 4)
        goto truncated;
      obj->bind_addr_ipv4 = ntohl(trunnel_get_uint32(ptr));
      remaining -= 4; ptr += 4;
      break;

    case ATYPE_IPV6:

      /* Parse u8 bind_addr_ipv6[16] */
      if (remaining < (16))
        goto truncated;
      memcpy(obj->bind_addr_ipv6, ptr, 16);
      {
        unsigned idx;
        for (idx = 0; idx < 16; ++idx)
          obj->bind_addr_ipv6[idx] = (obj->bind_addr_ipv6[idx]);
      }
      remaining -= 16; ptr += 16;
      break;

    case ATYPE_DOMAINNAME:

      /* Parse struct domainname bind_addr_domainname */
      result = domainname_parse_into(&obj->bind_addr_domainname, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    default:
      goto fail;
      break;
  }

  /* Parse u16 bind_port */
  if (remaining < 2)
    goto truncated;
  obj->bind_port = ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  if (result >= 0) result = -1;
  return result;
 fail:
  result = -1;
  return result;
}

ssize_t
1;2csocks5_server_reply_parse(socks5_server_reply_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = socks5_server_reply_new();
  result = socks5_server_reply_parse_into(*output, input, len_in);
  if (result < 0) {
    socks5_server_reply_free(*output);
    *output = NULL;
  }
  return result;
}
